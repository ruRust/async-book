# Типаж `Future`

Типаж `Future` является центральным для асинхронного программирования в Rust. `Future` - это асинхронное вычисление, которое может производить значение (хотя значение может быть и пустым, например `()`). 
*Упрощённый* вариант этого типажа может выглядеть как-то 
так:

```rust
{{#include ../../examples/02_02_future_trait/src/lib.rs:simple_future}}
```

Футуры могут прогрессировать при помощи функции `poll`, которая продвигает их к завершению на сколько это возможно. Если футура завершается, она возвращает `Poll::Ready(result)`. Если же она до сих пор не готова завершиться, то возвращает `Poll::Pending` и предоставляет функцию `wake()`, которая будет вызвана, когда `Future` будет готова продвинуться в своем прогрессе. Когда вызван `wake()`, исполнитель снова вызывает у `Future` метод `poll`, чтобы она смогла продвинуться далее.

Без `wake()`, исполнитель не имеет возможности узнать, когда какая-либо `future` может продвинуться, и был бы должен постоянно опрашивать каждую `future`. С помощью `wake()` исполнитель точно знает какие `future`s могут быть опрошены {code2}poll{/code2}-ed.

Например, представим ситуацию, когда мы хотим прочитать из сокета, который может иметь, а может и не иметь данных. Если данные есть, мы можем прочитать их и вернуть `Poll::Ready(data)`, но если данных ещё нет, наша `future` блокируется и не может прогрессировать. Когда данных нет, мы должны зарегистрировать вызов `wake`, когда данные появятся в сокете

```rust
{{#include ../../examples/02_02_future_trait/src/lib.rs:socket_read}}
```

Такая модель `Future` позволяет держать вместе несколько асинхронных операций без лишних промежуточных выделений памяти. Одновременный запуск нескольких `future`s или соединение их в цепочку может быть реализовано при помощи машины состояний, не делающий выделений памяти, например так:

```rust
{{#include ../../examples/02_02_future_trait/src/lib.rs:join}}
```

Здесь показано, как несколько футур могут быть запущены 
одновременно без необходимости раздельной аллокации, позволяя 
асинхронным программам быть более эффективными. Аналогично, 
несколько последовательных футур могут быть запущены одна за 
другой, как тут:

```rust
{{#include ../../examples/02_02_future_trait/src/lib.rs:and_then}}
```

Этот пример показывает, как типаж `Future` может 
использоваться для выражения асинхронного управления потоком 
без необходимости множественной аллокации объектов и глубоко 
вложенных замыканий. Давайте оставим базовое управление 
потоком в стороне и поговорим о реальном типаже 
`Future` и чем он отличается от написанного нами.

```rust
{{#include ../../examples/02_02_future_trait/src/lib.rs:real_future}}
```

Первое, что вы могли заметить, что наш тип `self` больше не `&mut self`, а заменён на `Pin<&mut Self>`. Мы поговорим о закреплении [в следующей секции], но пока что знайте, что оно позволяет создавать не перемещаемые `future`s. Не перемещаемые объекты могут сохранять указатели на собственные поля, например 
`struct MyFut { a: i32, ptr_to_a: *const i32 }`. Прикрепление необходимо для `async`/`await`.

Второе, `wake: fn()` была изменена на
`&mut Context<'_>`. В
`SimpleFuture` мы использовали вызов указателя на
функцию (`fn()`), чтобы сказать исполнителю, что
футура должна быть опрошена. Однако, из-за того, что `fn()`
- это всего лишь указатель на функцию, он не может сохранить информацию о том
_какая_ футура вызвала `wake`.

В примере из реального мира, сложное приложение типа web-сервера может иметь тысячи различных подключений, пробуждения которых должны обрабатываться по отдельности. Тип  `Context` решает это предоставляя доступ к значению типа `Waker`, который может быть использован для пробуждения конкретной задачи.


[в следующей секции]: ../04_pinning/01_chapter.md