# Применение: создание исполнителя

Футуры Rust'a ленивы: они ничего не будут делать, если не будут активно доводиться до завершения. Один из способов довести их до завершения - это `.await` внутри `async` функции, но это просто подталкивает проблему на один уровень вверх: кто будет запускать футуры, возвращённые из `async` функций верхнего уровня? Ответ в том, что нам нужен исполнитель для `Future`.

Исполнители берут набор future верхнего уровня и запускают их через вызов метода `poll`, до тех пока они не завершатся. Как правило, исполнитель будет вызывать метод  `poll` у future один раз, чтобы запустить. Когда future сообщают, что готовы продолжить вычисления при вызове метода  `wake()`, они помещаются обратно в очередь и вызов `poll` повторяется до тех пор, пока `Future` не будут завершены.

В этом разделе мы напишем нашего собственного простого исполнителя, способного одновременно запускать большое количество футур верхнего уровня.

Для этого примера мы используем пакет `futures`, в котором определён типаж `ArcWake`. Данный типаж предоставляет простой способ создания `Waker`.

```toml
[package]
name = "xyz"
version = "0.1.0"
authors = ["XYZ Author"]
edition = "2018"

[dependencies]
futures = "0.3"
```

Дальше, мы должны в верхней части `src/main.rs` импортировать следующее:

```rust
{{#include ../../examples/02_04_executor/src/lib.rs:imports}}
```

Наш исполнитель будет работать, посылая задачи для запуска по каналу. Исполнитель извлечёт события из канала и запустит их. Когда задача будет готова выполнить больше работы (будет пробуждена), она может запланировать повторный опрос самой себя, отправив себя обратно в канал.

В этом проекте самому исполнителю просто необходим получатель для канала задачи. Пользователь получит экземпляр отправителя, чтобы он мог создавать новые футуры. Сами задачи - это просто футуры, которые могут перезапланировать самих себя, поэтому мы сохраним их как сочетание футуры и отправителя, который задача может использовать, чтобы добавить себя в очередь.

```rust
{{#include ../../examples/02_04_executor/src/lib.rs:executor_decl}}
```

Давайте также добавим метод к `spawner`, чтобы было легко создавать новые `futures`. Этот метод возьмёт future, упакует и поместит его в `FutureObj` и создаст новую `Arc<Task>` с ней внутри, которая может быть поставлена в очередь исполнителя.

```rust
{{#include ../../examples/02_04_executor/src/lib.rs:spawn_fn}}
```

Чтобы опросить `futures`, нам нужно создать `Waker`. Как описано в разделе [задачи пробуждения], `Waker`s отвечают за планирование задач, которые будут опрошены снова после вызова `wake`. `Waker`s сообщают исполнителю, какая именно задача завершилась, позволяя опрашивать как раз те `futures`, которые готовы к продолжению выполнения. Простой способ создать новый `Waker`, необходимо реализовать типаж `ArcWake`, а затем использовать `waker_ref` или `.into_waker()` функции для преобразования `Arc<impl ArcWake>` в `Waker`. Давайте реализуем `ArcWake` для наших задач, чтобы они были превращены в `Waker`s и могли пробуждаться:

```rust
{{#include ../../examples/02_04_executor/src/lib.rs:arcwake_for_task}}
```

Когда `Waker` создаётся на основе `Arc<Task>`, вызывая `wake()`, это вызовет отправку копии `Arc` в канал задач. Тогда нашему исполнителю  нужно подобрать задание и опросить его. Давайте реализуем это:

```rust
{{#include ../../examples/02_04_executor/src/lib.rs:executor_run}}
```

Поздравляю! Теперь у нас есть работающий исполнитель `futures`. Мы даже можем использовать его для запуска `async/.await` кода и пользовательских `futures`, таких как `TimerFuture` которую мы описали ранее:

```rust
{{#include ../../examples/02_04_executor/src/lib.rs:main}}
```


[задачи пробуждения]: ./03_wakeups.md